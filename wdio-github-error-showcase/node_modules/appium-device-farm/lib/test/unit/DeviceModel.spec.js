"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const db_1 = require("../../src/data-service/db");
const device_service_1 = require("../../src/data-service/device-service");
const devices_1 = require("./fixtures/devices");
const chai_1 = require("chai");
const device_service_2 = require("../../src/data-service/device-service");
const sinon_1 = __importDefault(require("sinon"));
var sandbox = sinon_1.default.createSandbox();
describe('Model Test', () => __awaiter(void 0, void 0, void 0, function* () {
    before('Add device collection', () => __awaiter(void 0, void 0, void 0, function* () {
        const deviceModel = yield db_1.ATDRepository.DeviceModel;
        (yield db_1.ATDRepository.DeviceModel).removeDataOnly();
        (0, chai_1.expect)((yield db_1.ATDRepository.DeviceModel).chain().find().data().length).to.be.equal(0);
        (0, chai_1.expect)(devices_1.deviceMock.length).to.be.greaterThanOrEqual(1);
        // console.log(`deviceMock length: ${deviceMock.length}`);
        const result = (yield db_1.ATDRepository.DeviceModel).insert(devices_1.deviceMock);
        (yield db_1.ATDRepository.db).saveDatabase();
        // console.log(`result: ${result}`);
        // console.log(`device model length: ${deviceModel.find().length}`);
        (yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find()
            .data()
            .length.should.be.equal(devices_1.deviceMock.length);
    }));
    after('clean', () => {
        sandbox.restore();
    });
    it('Should remove device from old pool when new poll call does not have the device', () => __awaiter(void 0, void 0, void 0, function* () {
        const findDevice = (yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find({ udid: 'emulator-5570' })
            .data();
        (0, chai_1.expect)(findDevice.length).to.be.equal(1);
        yield (0, device_service_2.removeDevice)([{ udid: 'emulator-5570', host: '127.0.0.1' }]);
        const updatedDeviceList = (yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find({ udid: 'emulator-5570' })
            .data();
        (0, chai_1.expect)(updatedDeviceList).to.deep.equal([]);
    }));
    it('Should update new device polled into the existing device list', () => __awaiter(void 0, void 0, void 0, function* () {
        const newDeviceList = [
            {
                busy: false,
                state: 'device',
                udid: 'emulator-9994',
                platform: 'android',
            },
        ];
        yield (0, device_service_2.addNewDevice)(newDeviceList);
        const updatedDeviceList = (yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find({ udid: 'emulator-9994' })
            .data();
        (0, chai_1.expect)(updatedDeviceList.length).to.be.greaterThanOrEqual(1);
    }));
    it('Should update the ios simulator state from shutdown to booted', () => __awaiter(void 0, void 0, void 0, function* () {
        const newDeviceList = [
            {
                busy: false,
                state: 'device',
                udid: 'emulator-5554',
                platform: 'android',
                offline: false,
            },
            {
                busy: false,
                state: 'device',
                udid: 'emulator-5556',
                platform: 'android',
                offline: false,
            },
            {
                name: 'iPad Air',
                udid: '0FBCBDCC-2FF1-4FCA-B034-60ABC86ED888',
                state: 'Shutdown',
                deviceType: 'simulator',
                sdk: '13.5',
                platform: 'ios',
                busy: true,
                realDevice: false,
                offline: false,
            },
            {
                name: 'iPad Air (3rd generation)',
                udid: '0FBCBDCC-2FF1-4FCA-B034-60ABC86ED866',
                state: 'Shutdown',
                deviceType: 'simulator',
                sdk: '13.5',
                platform: 'ios',
                busy: false,
                realDevice: false,
                offline: false,
            },
        ];
        yield (0, device_service_2.setSimulatorState)(newDeviceList);
        const updatedDeviceList = (yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find({ udid: '0FBCBDCC-2FF1-4FCA-B034-60ABC86ED888' })
            .data();
        (0, chai_1.expect)(updatedDeviceList[0].state).to.be.equal('Shutdown');
    }));
    it('Should handle concurrent update to device list', () => __awaiter(void 0, void 0, void 0, function* () {
        // create bunch of devices using loop
        let newDeviceList = [];
        for (let i = 0; i < 10; i++) {
            newDeviceList.push({
                busy: false,
                state: 'device',
                udid: `emulator-${i}`,
                platform: 'android',
                offline: false,
            });
        }
        // create a function to add new device with random delay to simulate concurrent calls from multiple nodes
        const delayedAddDevice = (newDeviceList) => __awaiter(void 0, void 0, void 0, function* () {
            yield new Promise((resolve) => setTimeout(resolve, Math.random() * 1000));
            for (const device of newDeviceList) {
                yield new Promise((resolve) => setTimeout(resolve, Math.random() * 1000));
                yield (0, device_service_2.addNewDevice)([device]);
            }
        });
        const existingDevices = yield (0, device_service_1.getAllDevices)();
        // create some parallel calls to addNewDevice
        yield Promise.all([delayedAddDevice(newDeviceList), delayedAddDevice(existingDevices)]);
        // verify that all devices are added to the db
        const updatedDeviceList = (yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find({ platform: 'android' })
            .data();
        // every newDeviceList should be listed under updatedDeviceList
        // map udid only to make it simple
        const addedDeviceUdids = newDeviceList.map((device) => device.udid);
        const updatedDeviceUdids = updatedDeviceList.map((device) => device.udid);
        addedDeviceUdids.forEach((udid) => updatedDeviceUdids.includes(udid).should.be.true);
    }));
}));

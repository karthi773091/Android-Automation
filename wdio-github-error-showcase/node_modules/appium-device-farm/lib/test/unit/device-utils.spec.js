"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const sinon_1 = __importDefault(require("sinon"));
const DeviceUtils = __importStar(require("../../src/device-utils"));
const DeviceService = __importStar(require("../../src/data-service/device-service"));
const chai_1 = __importDefault(require("chai"));
const sinon_chai_1 = __importDefault(require("sinon-chai"));
const db_1 = require("../../src/data-service/db");
const ip_1 = __importDefault(require("ip"));
const device_service_1 = require("../../src/data-service/device-service");
const device_managers_1 = require("../../src/device-managers");
const typedi_1 = require("typedi");
const device_utils_1 = require("../../src/device-utils");
const IPluginArgs_1 = require("../../src/interfaces/IPluginArgs");
const uuid_1 = require("uuid");
chai_1.default.should();
chai_1.default.use(sinon_chai_1.default);
const expect = chai_1.default.expect;
const sandbox = sinon_1.default.createSandbox();
const NODE_ID = (0, uuid_1.v4)();
describe('Device Utils', () => {
    const hub1Device = {
        systemPort: 56205,
        sdk: '10',
        realDevice: true,
        name: 'emulator-5555',
        busy: false,
        state: 'device',
        udid: 'emulator-5555',
        tags: ['team1', 'team33'],
        platform: 'android',
        deviceType: 'real',
        host: 'http://192.168.0.225:4723',
        totalUtilizationTimeMilliSec: 40778,
        sessionStartTime: 1667113345897,
        offline: false,
        lastCmdExecutedAt: 1667113356356,
    };
    const hub2Device = {
        systemPort: 56205,
        sdk: '10',
        realDevice: true,
        name: 'emulator-5555',
        tags: ['team22', 'teamAutomation'],
        busy: false,
        state: 'device',
        udid: 'emulator-5555',
        platform: 'android',
        deviceType: 'real',
        host: 'http://192.168.0.226:4723',
        totalUtilizationTimeMilliSec: 40778,
        sessionStartTime: 1667113345897,
        offline: false,
        lastCmdExecutedAt: 1667113356356,
    };
    const localDeviceiOS = {
        name: 'iPhone SE (3rd generation)',
        udid: '14C1078F-74C1-4672-BDB7-B65FC85FBFB4',
        state: 'Shutdown',
        sdk: '16.0',
        platform: 'ios',
        wdaLocalPort: 53712,
        busy: false,
        realDevice: false,
        deviceType: 'simulator',
        host: `http://${ip_1.default.address()}:4723`,
        totalUtilizationTimeMilliSec: 0,
        sessionStartTime: 0,
        offline: false,
    };
    // device with no host
    const noHostDevice = {
        systemPort: 56205,
        sdk: '10',
        realDevice: true,
        name: 'emulator-9999',
        busy: false,
        state: 'device',
        udid: 'emulator-9999',
        platform: 'android',
        deviceType: 'real',
        totalUtilizationTimeMilliSec: 40778,
        sessionStartTime: 1667113345897,
        offline: false,
        lastCmdExecutedAt: 1667113356356,
        userBlocked: false,
    };
    const devices = [hub1Device, hub2Device, localDeviceiOS, noHostDevice];
    const pluginArgs = Object.assign({}, IPluginArgs_1.DefaultPluginArgs, {
        remote: [`http://${ip_1.default.address()}:4723`],
        iosDeviceType: 'both',
        androidDeviceType: 'both',
    });
    afterEach(function () {
        sandbox.restore();
    });
    it('Allocate devices for session with host filter', () => __awaiter(void 0, void 0, void 0, function* () {
        (yield db_1.ATDRepository.DeviceModel).removeDataOnly();
        const deviceManager = new device_managers_1.DeviceFarmManager('android', { androidDeviceType: 'both', iosDeviceType: 'both' }, 4723, Object.assign(pluginArgs, { maxSessions: 3 }), NODE_ID);
        typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
        yield (0, device_service_1.addNewDevice)(devices);
        const capabilities = {
            alwaysMatch: {
                platformName: 'android',
                'appium:app': '/Downloads/VodQA.apk',
                'appium:deviceAvailabilityTimeout': 1800,
                'appium:deviceRetryInterval': 100,
                'df:filterByHost': 'http://192.168.0.226:4723',
            },
            firstMatch: [{}],
        };
        const allocatedDeviceForFirstSession = yield DeviceUtils.allocateDeviceForSession(capabilities, 1000, 1000, pluginArgs);
        function getFilteredDevice(udid, host) {
            return __awaiter(this, void 0, void 0, function* () {
                return (yield db_1.ATDRepository.DeviceModel).chain().find({ udid, host }).data();
            });
        }
        const foundDevice = (yield getFilteredDevice(allocatedDeviceForFirstSession.udid, allocatedDeviceForFirstSession.host))[0];
        expect(foundDevice.busy).to.be.true;
        yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 1000, 1000, pluginArgs).catch((error) => expect(error)
            .to.be.an('error')
            .with.property('message', 'Device is busy or blocked.. Device request: {"platform":"android","udid":"emulator-5555","filterByHost":"http://192.168.0.226:4723"}'));
    }));
    it('Allocate devices for session with tag filter', () => __awaiter(void 0, void 0, void 0, function* () {
        (yield db_1.ATDRepository.DeviceModel).removeDataOnly();
        const deviceManager = new device_managers_1.DeviceFarmManager('android', { androidDeviceType: 'both', iosDeviceType: 'both' }, 4723, Object.assign(pluginArgs, { maxSessions: 3 }), NODE_ID);
        typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
        yield (0, device_service_1.addNewDevice)(devices);
        const capabilities = {
            alwaysMatch: {
                platformName: 'android',
                'appium:app': '/Downloads/VodQA.apk',
                'appium:deviceAvailabilityTimeout': 1800,
                'appium:deviceRetryInterval': 100,
                'df:options': {
                    tags: ['team1', 'teamAutomation'],
                },
            },
            firstMatch: [{}],
        };
        const allocatedDeviceForFirstSession = yield DeviceUtils.allocateDeviceForSession(capabilities, 1000, 1000, pluginArgs);
        function getFilteredDevice(udid, host) {
            return __awaiter(this, void 0, void 0, function* () {
                return (yield db_1.ATDRepository.DeviceModel).chain().find({ udid, host }).data();
            });
        }
        const foundDevice = (yield getFilteredDevice(allocatedDeviceForFirstSession.udid, allocatedDeviceForFirstSession.host))[0];
        expect(foundDevice.tags).to.be.deep.eq(['team1', 'team33']);
        const allocatedDeviceForSecondSession = yield DeviceUtils.allocateDeviceForSession(capabilities, 1000, 1000, pluginArgs);
        const foundSecondDevice = (yield getFilteredDevice(allocatedDeviceForSecondSession.udid, allocatedDeviceForSecondSession.host))[0];
        expect(foundSecondDevice.tags).to.be.deep.eq(['team22', 'teamAutomation']);
        yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 1000, 1000, pluginArgs).catch((error) => expect(error)
            .to.be.an('error')
            .with.property('message', 'Device is busy or blocked.. Device request: {"platform":"android","udid":"emulator-5555","tags":["team1","teamAutomation"]}'));
    }));
    it('Allocating device should set device to be busy', function () {
        return __awaiter(this, void 0, void 0, function* () {
            (yield db_1.ATDRepository.DeviceModel).removeDataOnly();
            const deviceManager = new device_managers_1.DeviceFarmManager('android', { androidDeviceType: 'both', iosDeviceType: 'both' }, 4723, Object.assign(pluginArgs, { maxSessions: 3 }), NODE_ID);
            typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
            yield (0, device_service_1.addNewDevice)(devices);
            const capabilities = {
                alwaysMatch: {
                    platformName: 'android',
                    'appium:app': '/Downloads/VodQA.apk',
                    'appium:deviceAvailabilityTimeout': 1800,
                    'appium:deviceRetryInterval': 100,
                },
                firstMatch: [{}],
            };
            const allocatedDeviceForFirstSession = yield DeviceUtils.allocateDeviceForSession(capabilities, 1000, 1000, pluginArgs);
            function getFilteredDevice(udid, host) {
                return __awaiter(this, void 0, void 0, function* () {
                    return (yield db_1.ATDRepository.DeviceModel).chain().find({ udid, host }).data();
                });
            }
            const foundDevice = (yield getFilteredDevice(allocatedDeviceForFirstSession.udid, allocatedDeviceForFirstSession.host))[0];
            expect(foundDevice.busy).to.be.true;
            let filterDeviceWithSameUDID = (yield db_1.ATDRepository.DeviceModel)
                .chain()
                .find({ udid: allocatedDeviceForFirstSession.udid })
                .data();
            expect(filterDeviceWithSameUDID.length).to.be.equal(2);
            // one device should be busy and the other is not
            filterDeviceWithSameUDID.filter((device) => device.busy).length.should.be.equal(1);
            filterDeviceWithSameUDID.filter((device) => !device.busy).length.should.be.equal(1);
            const allocatedDeviceForSecondSession = yield DeviceUtils.allocateDeviceForSession(capabilities, 1000, 1000, pluginArgs);
            // allocatedDeviceForSecondSession should not be the same as allocatedDeviceForFirstSession
            expect(allocatedDeviceForFirstSession).to.not.be.equal(allocatedDeviceForSecondSession);
            const foundSecondDevice = (yield db_1.ATDRepository.DeviceModel)
                .chain()
                .find({
                udid: allocatedDeviceForSecondSession.udid,
                host: allocatedDeviceForSecondSession.host,
            })
                .data()[0];
            // check that the device is busy
            filterDeviceWithSameUDID = (yield db_1.ATDRepository.DeviceModel)
                .chain()
                .find({ udid: allocatedDeviceForFirstSession.udid })
                .data();
            expect(filterDeviceWithSameUDID[0].busy).to.be.true;
            expect(filterDeviceWithSameUDID[1].busy).to.be.true;
            expect(foundSecondDevice.busy).to.be.true;
            yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 1000, 1000, pluginArgs).catch((error) => expect(error)
                .to.be.an('error')
                .with.property('message', 'Device is busy or blocked.. Device request: {"platform":"android","udid":"emulator-5555"}'));
        });
    });
    it('should release blocked devices that have no activity for more than the timeout', () => __awaiter(void 0, void 0, void 0, function* () {
        // Mock the dependencies and setup the test data
        const getAllDevicesMock = () => [
            {
                udid: 'device1',
                busy: true,
                host: ip_1.default.address(),
                lastCmdExecutedAt: new Date().getTime() - (IPluginArgs_1.DefaultPluginArgs.newCommandTimeoutSec + 5) * 1000,
            },
            {
                udid: 'device2',
                busy: true,
                host: ip_1.default.address(),
                lastCmdExecutedAt: new Date().getTime() - 30000,
                newCommandTimeout: 20000 / 1000,
            },
            { udid: 'device3', busy: true, host: ip_1.default.address(), lastCmdExecutedAt: new Date().getTime() },
            { udid: 'device4', busy: true, host: ip_1.default.address() },
        ];
        sandbox.stub(DeviceService, 'getAllDevices').callsFake(getAllDevicesMock);
        const unblockDeviceMock = sandbox.stub(DeviceService, 'unblockDevice').callsFake(sinon_1.default.fake());
        // Call the function under test
        yield DeviceUtils.releaseBlockedDevices(IPluginArgs_1.DefaultPluginArgs.newCommandTimeoutSec);
        // Verify the expected behavior
        unblockDeviceMock.should.have.been.calledTwice;
        unblockDeviceMock.should.have.been.calledWith('device1', ip_1.default.address());
        unblockDeviceMock.should.have.been.calledWith('device2', ip_1.default.address());
        unblockDeviceMock.should.not.have.been.calledWith('device3', ip_1.default.address());
        unblockDeviceMock.should.not.have.been.calledWith('device3', ip_1.default.address());
    }));
    it('should release device on node that is not used for more than the timeout', () => __awaiter(void 0, void 0, void 0, function* () {
        // spec: we have devices from different hosts, all of them are busy and one of them is not used for more than the timeout
        const getAllDevicesMock = () => [
            {
                udid: 'device1',
                busy: true,
                host: 'http://anotherhost:4723',
                lastCmdExecutedAt: new Date().getTime() - 30000,
                newCommandTimeout: 20000 / 1000,
            },
            { udid: 'device2', busy: true, host: ip_1.default.address(), lastCmdExecutedAt: new Date().getTime() },
            // user blocked device
            {
                udid: 'device3',
                busy: true,
                host: ip_1.default.address(),
                userBlocked: true,
                lastCmdExecutedAt: new Date().getTime() - 30000,
                newCommandTimeout: 20000 / 1000,
            },
        ];
        sandbox.stub(DeviceService, 'getAllDevices').callsFake(getAllDevicesMock);
        const unblockDeviceMock = sandbox.stub(DeviceService, 'unblockDevice').callsFake(sinon_1.default.fake());
        // calling releaseBlockedDevices should release the device on anotherhost
        yield DeviceUtils.releaseBlockedDevices(IPluginArgs_1.DefaultPluginArgs.newCommandTimeoutSec);
        // Verify the expected behavior
        unblockDeviceMock.should.have.been.calledOnce;
        unblockDeviceMock.should.have.been.calledWith('device1', 'http://anotherhost:4723');
        unblockDeviceMock.should.have.not.been.calledWith('device3', ip_1.default.address());
    }));
    it('Block and unblock device', () => __awaiter(void 0, void 0, void 0, function* () {
        (yield db_1.ATDRepository.DeviceModel).removeDataOnly();
        // mock setUtilizationTime
        sandbox.stub(DeviceUtils, 'setUtilizationTime').callsFake(sinon_1.default.fake());
        const unbusyDevices = devices.map((device) => (Object.assign(Object.assign({}, device), { busy: false })));
        yield (0, device_service_1.addNewDevice)(unbusyDevices);
        const targetDevice = unbusyDevices[0];
        // action: block device
        yield DeviceService.blockDevice(targetDevice.udid, targetDevice.host);
        // assert device is busy
        expect((yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find({ udid: targetDevice.udid, host: targetDevice.host })
            .data()[0]).to.have.property('busy', true);
        // set lastCommandTimestamp, otherwise it won't be picked up as device to unblock
        (yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find({ udid: targetDevice.udid, host: targetDevice.host })
            .update(function (device) {
            device.lastCmdExecutedAt = new Date().getTime();
        });
        let unblockCandidates = yield DeviceUtils.unblockCandidateDevices();
        //console.log(unblockCandidates);
        // assert: device should be part of candidate list to unblock
        expect(unblockCandidates.map((item) => item.udid)).to.include(targetDevice.udid);
        // action: release blocked devices
        yield DeviceService.unblockDevice(targetDevice.udid, targetDevice.host);
        // assert: device should not be part of candidate list to unblock
        unblockCandidates = yield DeviceUtils.unblockCandidateDevices();
        expect((yield unblockCandidates).map((item) => item.udid)).to.not.include(targetDevice.udid);
        // assert: device should not have lastCommandTimestamp or it should be undefined
        const device = (yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find({ udid: targetDevice.udid, host: targetDevice.host })
            .data()[0];
        expect(device).to.be.not.undefined;
        expect(device === null || device === void 0 ? void 0 : device.lastCmdExecutedAt).to.be.undefined;
    }));
    it('should remove stale devices', () => __awaiter(void 0, void 0, void 0, function* () {
        (yield db_1.ATDRepository.DeviceModel).removeDataOnly();
        const deviceManager = new device_managers_1.DeviceFarmManager('android', { androidDeviceType: 'both', iosDeviceType: 'both' }, 4723, Object.assign(pluginArgs, { maxSessions: 3 }), NODE_ID);
        typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
        (0, device_service_1.addNewDevice)(devices);
        DeviceUtils.removeStaleDevices(pluginArgs.bindHostOrIp);
        // assert emulator-9999 is removed
        expect((yield db_1.ATDRepository.DeviceModel).chain().find({ udid: 'emulator-9999' }).data().length).to.be.equal(0);
    }));
});

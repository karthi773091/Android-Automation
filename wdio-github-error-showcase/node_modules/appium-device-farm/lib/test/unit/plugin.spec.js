"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const device_utils_1 = require("../../src/device-utils");
const chai_1 = require("chai");
const pluginArgs_1 = require("../../src/data-service/pluginArgs");
const cliArgs_1 = require("../integration/cliArgs");
const db_1 = require("../../src/data-service/db");
const IPluginArgs_1 = require("../../src/interfaces/IPluginArgs");
const CapabilityManager_1 = require("../../src/CapabilityManager");
const pluginArgs = IPluginArgs_1.DefaultPluginArgs;
describe('Device filter tests', () => {
    it('Get Device filters for real device', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, pluginArgs_1.addCLIArgs)(cliArgs_1.serverCliArgs);
        (yield db_1.ATDRepository.CLIArgs)
            .chain()
            .find()
            .update(function (d) {
            d.plugin['device-farm'].iosDeviceType = 'real';
        });
        const capabilities = {
            alwaysMatch: {
                platformName: 'iOS',
                'appium:app': '/Downloads/VodQA.ipa',
                'df:iPhoneOnly': true,
                'appium:platformVersion': '14.0',
                'appium:udid': '21112-1111-1111-111',
            },
            firstMatch: [{}],
        };
        const firstMatch = Object.assign({}, capabilities.firstMatch[0], capabilities.alwaysMatch);
        const deviceFarmCapabilities = (0, CapabilityManager_1.getDeviceFarmCapabilities)(capabilities);
        const filter = (0, device_utils_1.getDeviceFiltersFromCapability)(firstMatch, deviceFarmCapabilities, pluginArgs);
        (0, chai_1.expect)(filter).to.deep.equal({
            platform: 'ios',
            platformVersion: '14.0',
            name: 'iPhone',
            deviceType: 'real',
            udid: '21112-1111-1111-111',
            minSDK: undefined,
            maxSDK: undefined,
            filterByHost: undefined,
            tags: undefined,
            busy: false,
            userBlocked: false,
        });
    }));
    it('Get Device from filter properties for simulator', () => __awaiter(void 0, void 0, void 0, function* () {
        (yield db_1.ATDRepository.CLIArgs)
            .chain()
            .find()
            .update(function (d) {
            d.plugin['device-farm'].iosDeviceType = 'simulated';
        });
        const capabilities = {
            alwaysMatch: {
                platformName: 'iOS',
                'appium:app': '/Downloads/VodQA.app',
                'df:iPhoneOnly': true,
                'appium:platformVersion': '14.0',
            },
            firstMatch: [{}],
        };
        const firstMatch = Object.assign({}, capabilities.firstMatch[0], capabilities.alwaysMatch);
        const deviceFarmCapabilities = (0, CapabilityManager_1.getDeviceFarmCapabilities)(capabilities);
        const filter = (0, device_utils_1.getDeviceFiltersFromCapability)(firstMatch, deviceFarmCapabilities, pluginArgs);
        (0, chai_1.expect)(filter).to.deep.equal({
            platform: 'ios',
            platformVersion: '14.0',
            name: 'iPhone',
            filterByHost: undefined,
            deviceType: 'simulator',
            udid: undefined,
            minSDK: undefined,
            maxSDK: undefined,
            tags: undefined,
            busy: false,
            userBlocked: false,
        });
    }));
    it('Get Device filter properties with minSDK', () => {
        const capabilities = {
            alwaysMatch: {
                platformName: 'iOS',
                'appium:app': '/Downloads/VodQA.app',
                'df:minSDK': '10.2.0',
                'df:options': {
                    iPhoneOnly: true,
                },
            },
            firstMatch: [{}],
        };
        const firstMatch = Object.assign({}, capabilities.firstMatch[0], capabilities.alwaysMatch);
        const deviceFarmCapabilities = (0, CapabilityManager_1.getDeviceFarmCapabilities)(capabilities);
        const filter = (0, device_utils_1.getDeviceFiltersFromCapability)(firstMatch, deviceFarmCapabilities, pluginArgs);
        (0, chai_1.expect)(filter).to.deep.equal({
            platform: 'ios',
            filterByHost: undefined,
            platformVersion: undefined,
            name: 'iPhone',
            deviceType: 'simulator',
            udid: undefined,
            minSDK: '10.2.0',
            maxSDK: undefined,
            tags: undefined,
            busy: false,
            userBlocked: false,
        });
    });
});
describe('Pending sessions', () => __awaiter(void 0, void 0, void 0, function* () {
    it('clean pending sessions', () => __awaiter(void 0, void 0, void 0, function* () {
        // insert pending sessions
        (yield db_1.ATDRepository.PendingSessionsModel).insert({
            capability_id: '1',
            createdAt: new Date().getTime(),
        });
        (yield db_1.ATDRepository.PendingSessionsModel).insert({
            capability_id: '2',
            createdAt: new Date().getTime() - 10000,
        });
        // clean pending sessions
        yield (0, device_utils_1.cleanPendingSessions)(5000);
        // check pending sessions
        const pendingSessions = (yield db_1.ATDRepository.PendingSessionsModel).chain().data();
        (0, chai_1.expect)(pendingSessions.length).to.equal(1);
    }));
}));

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = __importStar(require("chai"));
const device_managers_1 = require("../../src/device-managers");
const typedi_1 = require("typedi");
const db_1 = require("../../src/data-service/db");
const device_utils_1 = require("../../src/device-utils");
const IPluginArgs_1 = require("../../src/interfaces/IPluginArgs");
const ip_1 = __importDefault(require("ip"));
const async_wait_until_1 = __importDefault(require("async-wait-until"));
const device_service_1 = require("../../src/data-service/device-service");
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const uuid_1 = require("uuid");
chai_1.default.use(chai_as_promised_1.default);
const pluginArgs = Object.assign({}, IPluginArgs_1.DefaultPluginArgs, {
    remote: [`http://${ip_1.default.address()}:4723`],
    skipChromeDownload: true,
});
const NODE_ID = (0, uuid_1.v4)();
describe('Android Test', () => {
    const deviceManager = new device_managers_1.DeviceFarmManager('android', { androidDeviceType: 'both', iosDeviceType: 'both' }, 4723, Object.assign(pluginArgs, {}), NODE_ID);
    before(() => __awaiter(void 0, void 0, void 0, function* () {
        (yield db_1.ATDRepository.DeviceModel).removeDataOnly();
        // adb devices should return devices
        (0, chai_1.expect)(deviceManager.getDevices()).to.eventually.have.length.greaterThan(0, 'No devices detected. Is adb running? Is there at least one device connected?');
    }));
    it('Allocate free device and verify the device state is busy in db', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, device_utils_1.initializeStorage)();
        yield deviceManager.getDevices();
        typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
        const hub = pluginArgs.hub;
        yield (0, device_utils_1.updateDeviceList)(pluginArgs.bindHostOrIp, hub);
        yield (0, device_utils_1.cleanPendingSessions)(0);
        yield (0, device_service_1.unblockDeviceMatchingFilter)({});
        const capabilities = {
            alwaysMatch: {
                platformName: 'android',
                'appium:app': '/Downloads/VodQA.apk',
                'appium:deviceAvailabilityTimeout': 1800,
                'appium:deviceRetryInterval': 100,
            },
            firstMatch: [{}],
        };
        const devices = yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 1000, 1000, pluginArgs);
        const allDeviceIds = (yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find({ udid: devices.udid })
            .data();
        (0, chai_1.expect)(allDeviceIds[0].busy).to.be.true;
    }));
    it.skip('Allocate second free device and verify both the device state is busy in db', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, device_utils_1.initializeStorage)();
        const deviceManager = new device_managers_1.DeviceFarmManager('android', { androidDeviceType: 'both', iosDeviceType: 'both' }, 4723, Object.assign({}, IPluginArgs_1.DefaultPluginArgs, pluginArgs), NODE_ID);
        typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
        yield (0, device_utils_1.updateDeviceList)(pluginArgs.bindHostOrIp);
        const capabilities = {
            alwaysMatch: {
                platformName: 'android',
                'appium:app': '/Downloads/VodQA.apk',
                'appium:deviceAvailabilityTimeout': 1800,
                'appium:deviceRetryInterval': 100,
            },
            firstMatch: [{}],
        };
        // wait until there are two devices and both are not offline
        let devices;
        (0, async_wait_until_1.default)(() => __awaiter(void 0, void 0, void 0, function* () {
            yield (0, device_utils_1.updateDeviceList)(pluginArgs.bindHostOrIp);
            devices = yield deviceManager.getDevices();
            return devices.length === 2 && devices.every((device) => !device.offline);
        }));
        yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 1000, 1000, pluginArgs);
        const allDeviceIds = (yield db_1.ATDRepository.DeviceModel).chain().find().data();
        allDeviceIds.forEach((device) => (0, chai_1.expect)(device.busy).to.be.true);
    }));
    it('Finding a device should throw error when all devices are busy', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, device_utils_1.initializeStorage)();
        const deviceManager = new device_managers_1.DeviceFarmManager('android', { androidDeviceType: 'both', iosDeviceType: 'both' }, 4723, pluginArgs, NODE_ID);
        typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
        const hub = pluginArgs.hub;
        yield (0, device_utils_1.updateDeviceList)(pluginArgs.bindHostOrIp, hub);
        const capabilities = {
            alwaysMatch: {
                platformName: 'android',
                'appium:app': '/Downloads/VodQA.apk',
                'appium:deviceAvailabilityTimeout': 1800,
                'appium:deviceRetryInterval': 100,
            },
            firstMatch: [{}],
        };
        yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 1000, 1000, pluginArgs).catch((error) => (0, chai_1.expect)(error)
            .to.be.an('error')
            .with.property('message', 'Device is busy or blocked.. Device request: {"platform":"android"}'));
    }));
});

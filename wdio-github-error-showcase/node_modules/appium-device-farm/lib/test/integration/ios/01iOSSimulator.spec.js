"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const device_managers_1 = require("../../../src/device-managers");
const typedi_1 = require("typedi");
const device_utils_1 = require("../../../src/device-utils");
const db_1 = require("../../../src/data-service/db");
const node_simctl_1 = __importDefault(require("node-simctl"));
const pluginArgs_1 = require("../../../src/data-service/pluginArgs");
const cliArgs_1 = require("../cliArgs");
const ip_1 = __importDefault(require("ip"));
const IPluginArgs_1 = require("../../../src/interfaces/IPluginArgs");
const device_service_1 = require("../../../src/data-service/device-service");
const lodash_1 = require("lodash");
const uuid_1 = require("uuid");
const simctl = new node_simctl_1.default();
const name = 'My Device Name';
const NODE_ID = (0, uuid_1.v4)();
const pluginArgs = Object.assign({}, IPluginArgs_1.DefaultPluginArgs, {
    remote: [`http://${ip_1.default.address()}:4723`],
    iosDeviceType: 'both',
});
function markSimulatorsAsBooted() {
    return __awaiter(this, void 0, void 0, function* () {
        const deviceModel = yield db_1.ATDRepository.DeviceModel;
        // mark simulators as booted
        deviceModel.findAndUpdate({ platform: 'ios', deviceType: 'simulator' }, (device) => {
            device.state = 'Booted';
        });
        //const simulators = (await ADTDatabase.DeviceModel).chain().find({ platform: 'ios', deviceType: 'simulator' }).data()
        //console.log('simulators: ', simulators);
    });
}
function initDeviceFarm(iosDeviceType) {
    return __awaiter(this, void 0, void 0, function* () {
        const pluginArgs = Object.assign({}, IPluginArgs_1.DefaultPluginArgs, {
            remote: [`http://${ip_1.default.address()}:4723`],
            iosDeviceType: iosDeviceType,
        });
        yield (0, device_utils_1.initializeStorage)();
        const deviceManager = new device_managers_1.DeviceFarmManager('ios', {
            iosDeviceType: 'simulated',
            androidDeviceType: 'real',
        }, 4723, Object.assign(pluginArgs, { maxSessions: 1 }), NODE_ID);
        (0, chai_1.expect)(deviceManager.getMaxSessionCount()).to.be.eql(1);
        typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
        const hub = pluginArgs.hub;
        yield (0, device_utils_1.updateDeviceList)(pluginArgs.bindHostOrIp, hub);
        yield markSimulatorsAsBooted();
        yield (0, device_service_1.unblockDeviceMatchingFilter)({});
        yield (0, device_utils_1.cleanPendingSessions)(0);
    });
}
describe('Max sessions CLI argument test', () => {
    before('Add Args', () => __awaiter(void 0, void 0, void 0, function* () {
        (yield db_1.ATDRepository.DeviceModel).removeDataOnly();
        yield (0, pluginArgs_1.addCLIArgs)(cliArgs_1.serverCliArgs);
    }));
    beforeEach('Release devices', () => __awaiter(void 0, void 0, void 0, function* () {
        yield initDeviceFarm('simulated');
    }));
    it('Allocate first device without issue', () => __awaiter(void 0, void 0, void 0, function* () {
        const capabilities = {
            alwaysMatch: {
                platformName: 'iOS',
                'appium:app': '/Downloads/VodQA.app',
                'appium:iPhoneOnly': true,
                'appium:deviceAvailabilityTimeout': 1800,
                'appium:deviceRetryInterval': 100,
            },
            firstMatch: [{}],
        };
        const device = yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 6000, 1000, pluginArgs);
        const allDeviceIds = (yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find({ udid: device.udid })
            .data();
        (0, chai_1.expect)(allDeviceIds[0].busy).to.be.true;
    }));
    it('Should throw error if the app does not match with device type', () => __awaiter(void 0, void 0, void 0, function* () {
        const capabilities = {
            alwaysMatch: {
                platformName: 'iOS',
                'appium:app': '/Downloads/VodQA.ipa',
                'appium:iPhoneOnly': true,
                'appium:deviceAvailabilityTimeout': 1800,
                'appium:deviceRetryInterval': 100,
            },
            firstMatch: [{}],
        };
        yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 6000, 100, Object.assign({}, pluginArgs, { iosDeviceType: 'simulated' })).catch((error) => (0, chai_1.expect)(error)
            .to.be.an('error')
            .with.property('message', 'iosDeviceType value is set to "simulated" but app provided is not suitable for simulator device.'));
    }));
    it('Throw error when all sessions occupied', () => __awaiter(void 0, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        yield (0, device_utils_1.initializeStorage)();
        const deviceManager = new device_managers_1.DeviceFarmManager('ios', { iosDeviceType: 'simulated', androidDeviceType: 'real' }, 4723, Object.assign(pluginArgs, { maxSessions: 1 }), NODE_ID);
        // set all devices to busy
        const allDevices = yield deviceManager.getDevices();
        try {
            for (var _d = true, allDevices_1 = __asyncValues(allDevices), allDevices_1_1; allDevices_1_1 = yield allDevices_1.next(), _a = allDevices_1_1.done, !_a; _d = true) {
                _c = allDevices_1_1.value;
                _d = false;
                const device = _c;
                (yield db_1.ATDRepository.DeviceModel)
                    .chain()
                    .find({ platform: 'ios' })
                    .update((device) => {
                    device.busy = true;
                });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = allDevices_1.return)) yield _b.call(allDevices_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const capabilities = {
            alwaysMatch: {
                platformName: 'iOS',
                'appium:app': '/Downloads/VodQA.app',
                'appium:iPhoneOnly': true,
                'appium:deviceAvailabilityTimeout': 1800,
                'appium:deviceRetryInterval': 100,
            },
            firstMatch: [{}],
        };
        yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 6000, 1000, pluginArgs).catch((error) => (0, chai_1.expect)(error)
            .to.be.an('error')
            .with.property('message', 'Device is busy or blocked.. Device request: {"platform":"ios","deviceType":"simulator"}'));
    }));
});
describe('IOS Simulator Test', () => {
    beforeEach('Release devices', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, device_service_1.unblockDeviceMatchingFilter)({});
    }));
    it('Should find free iPhone simulator when app path has .app extension and set busy status to true', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, device_utils_1.initializeStorage)();
        const deviceManager = new device_managers_1.DeviceFarmManager('ios', { iosDeviceType: 'both', androidDeviceType: 'real' }, 4723, pluginArgs, NODE_ID);
        typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
        const hub = pluginArgs.hub;
        yield (0, device_utils_1.updateDeviceList)(pluginArgs.bindHostOrIp, hub);
        yield markSimulatorsAsBooted();
        yield (0, device_service_1.unblockDeviceMatchingFilter)({});
        yield (0, device_utils_1.cleanPendingSessions)(0);
        const capabilities = {
            alwaysMatch: {
                platformName: 'iOS',
                'appium:app': '/Downloads/VodQA.app',
                'df:iPhoneOnly': true,
                'df:deviceAvailabilityTimeout': 1800,
                'df:deviceRetryInterval': 100,
            },
            firstMatch: [{}],
        };
        // console.log('devices: ', await deviceManager.getDevices())
        const device = yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 6000, 1000, pluginArgs);
        const allocatedSimulator = (yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find({ udid: device.udid })
            .data();
        const foundSimulator = allocatedSimulator[0];
        (0, chai_1.expect)(foundSimulator.busy).to.be.true;
        (0, chai_1.expect)(foundSimulator.name).to.match(/^iPhone/);
        (0, chai_1.expect)(foundSimulator.wdaLocalPort).to.match(/[0-9]/);
    }));
    it('Should find free iPad simulator when app path has .app extension and set busy status to true', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, device_utils_1.initializeStorage)();
        const deviceManager = new device_managers_1.DeviceFarmManager('ios', { iosDeviceType: 'both', androidDeviceType: 'real' }, 4723, pluginArgs, NODE_ID);
        typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
        const hub = pluginArgs.hub;
        yield (0, device_utils_1.updateDeviceList)(pluginArgs.bindHostOrIp, hub);
        yield markSimulatorsAsBooted();
        yield (0, device_service_1.unblockDeviceMatchingFilter)({});
        yield (0, device_utils_1.cleanPendingSessions)(0);
        const capabilities = {
            alwaysMatch: {
                platformName: 'iOS',
                'appium:app': '/Downloads/VodQA.app',
                'appium:iPadOnly': true,
                'appium:deviceAvailabilityTimeout': 1800,
                'appium:deviceRetryInterval': 100,
            },
            firstMatch: [{}],
        };
        // console.log('devices: ', await deviceManager.getDevices())
        const device = yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 6000, 1000, pluginArgs);
        const allocatedSimulator = (yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find({ udid: device.udid })
            .data();
        const foundSimulator = allocatedSimulator[0];
        (0, chai_1.expect)(foundSimulator.busy).to.be.true;
        (0, chai_1.expect)(foundSimulator.name).to.match(/^iPad/);
        (0, chai_1.expect)(foundSimulator.wdaLocalPort).to.match(/[0-9]/);
    }));
    it('Should find free Apple TV simulator and set busy status to true', function () {
        return __awaiter(this, void 0, void 0, function* () {
            if (process.env.CI) {
                yield (0, device_utils_1.initializeStorage)();
                const deviceManager = new device_managers_1.DeviceFarmManager('ios', { iosDeviceType: 'both', androidDeviceType: 'real' }, 4723, pluginArgs, NODE_ID);
                typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
                const hub = pluginArgs.hub;
                yield (0, device_utils_1.updateDeviceList)(pluginArgs.bindHostOrIp, hub);
                yield markSimulatorsAsBooted();
                yield (0, device_service_1.unblockDeviceMatchingFilter)({});
                yield (0, device_utils_1.cleanPendingSessions)(0);
                const capabilities = {
                    alwaysMatch: {
                        platformName: 'tvOS',
                        'appium:deviceAvailabilityTimeout': 1800,
                        'appium:deviceRetryInterval': 100,
                    },
                    firstMatch: [{}],
                };
                const device = yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 6000, 1000, pluginArgs);
                const allocatedSimulator = (yield db_1.ATDRepository.DeviceModel)
                    .chain()
                    .find({ udid: device.udid })
                    .data();
                const foundSimulator = allocatedSimulator[0];
                (0, chai_1.expect)(foundSimulator.busy).to.be.true;
                (0, chai_1.expect)(foundSimulator.name).to.match(/^Apple TV/);
                (0, chai_1.expect)(foundSimulator.wdaLocalPort).to.match(/[0-9]/);
            }
            else {
                this.skip();
            }
        });
    });
});
describe('Boot simulator test', () => __awaiter(void 0, void 0, void 0, function* () {
    before('Boot simulator', () => __awaiter(void 0, void 0, void 0, function* () {
        const list = yield simctl.list();
        const version = list.runtimes[0].version;
        const devices = (0, lodash_1.flatten)(Object.keys(list.devices).map((key) => list.devices[key]));
        //console.log('devices: ', devices);
        // find device is isAvailable=true
        const availableDevices = devices.filter((device) => device.isAvailable);
        //console.log('availableDevices: ', availableDevices);
        // find device name starts with iPhone
        const iphone = availableDevices.find((device) => device.name.startsWith('iPhone'));
        simctl.udid = yield simctl.createDevice(name, iphone.name, version);
        yield simctl.bootDevice();
        yield simctl.startBootMonitor({ timeout: 160000 });
    }));
    beforeEach('Release devices', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, device_service_1.unblockDeviceMatchingFilter)({});
    }));
    it('Should pick Booted simulator when app path has .app', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, device_utils_1.initializeStorage)();
        const deviceManager = new device_managers_1.DeviceFarmManager('ios', { iosDeviceType: 'both', androidDeviceType: 'real' }, 4723, Object.assign({}, IPluginArgs_1.DefaultPluginArgs, pluginArgs), NODE_ID);
        typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
        const hub = pluginArgs.hub;
        yield (0, device_utils_1.updateDeviceList)(pluginArgs.bindHostOrIp, hub);
        const capabilities = {
            alwaysMatch: {
                platformName: 'iOS',
                'appium:app': '/Downloads/VodQA.app',
                'appium:deviceAvailabilityTimeout': 1800,
                'appium:deviceRetryInterval': 100,
            },
            firstMatch: [{}],
        };
        const devices = yield deviceManager.getDevices();
        const device = yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 6000, 1000, pluginArgs);
        const allocatedSimulator = (yield db_1.ATDRepository.DeviceModel)
            .chain()
            .find({ udid: device.udid })
            .data();
        (0, chai_1.expect)(allocatedSimulator[0].state).to.be.equal('Booted');
    }));
    after('Delete simulator', () => __awaiter(void 0, void 0, void 0, function* () {
        if (simctl.udid)
            yield simctl.deleteDevice(simctl.udid);
    }));
}));

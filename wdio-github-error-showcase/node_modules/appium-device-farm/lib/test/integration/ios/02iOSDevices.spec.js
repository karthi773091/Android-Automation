"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const device_managers_1 = require("../../../src/device-managers");
const typedi_1 = require("typedi");
const ip_1 = __importDefault(require("ip"));
const device_utils_1 = require("../../../src/device-utils");
const db_1 = require("../../../src/data-service/db");
const IPluginArgs_1 = require("../../../src/interfaces/IPluginArgs");
const device_service_1 = require("../../../src/data-service/device-service");
const uuid_1 = require("uuid");
const pluginArgs = Object.assign({}, IPluginArgs_1.DefaultPluginArgs, {
    remote: [`http://${ip_1.default.address()}:4723`],
    iosDeviceType: 'both',
});
const NODE_ID = (0, uuid_1.v4)();
describe('IOS Test', () => {
    beforeEach('Release devices', () => __awaiter(void 0, void 0, void 0, function* () {
        // unblock all otherwise it will stuck on max session count
        yield (0, device_service_1.unblockDeviceMatchingFilter)({});
    }));
    it('Throw error when no device is found for given capabilities', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, device_utils_1.initializeStorage)();
        (yield db_1.ATDRepository.CLIArgs)
            .chain()
            .find()
            .update(function (d) {
            d.plugin['device-farm'].iosDeviceType = 'real';
        });
        const deviceManager = new device_managers_1.DeviceFarmManager('ios', { iosDeviceType: 'both', androidDeviceType: 'real' }, 4723, pluginArgs, NODE_ID);
        typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
        yield (0, device_utils_1.updateDeviceList)(pluginArgs.bindHostOrIp);
        const capabilities = {
            alwaysMatch: {
                platformName: 'iOS',
                'appium:app': '/Downloads/VodQA.ipa',
                'appium:iPhoneOnly': true,
                'appium:deviceAvailabilityTimeout': 1800,
                'appium:deviceRetryInterval': 100,
            },
            firstMatch: [{}],
        };
        yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 6000, 1000, pluginArgs).catch((error) => (0, chai_1.expect)(error)
            .to.be.an('error')
            .with.property('message', 'No device matching request.. Device request: {"platform":"ios","deviceType":"real"}'));
    }));
    it('Should throw error if the IPA does not match with device type real', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, device_utils_1.initializeStorage)();
        const deviceManager = new device_managers_1.DeviceFarmManager('ios', { iosDeviceType: 'both', androidDeviceType: 'real' }, 4723, pluginArgs, NODE_ID);
        typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
        yield (0, device_utils_1.updateDeviceList)(pluginArgs.bindHostOrIp);
        const capabilities = {
            alwaysMatch: {
                platformName: 'iOS',
                'appium:app': '/Downloads/VodQA.zip',
                'appium:iPhoneOnly': true,
                'appium:deviceAvailabilityTimeout': 1800,
                'appium:deviceRetryInterval': 100,
            },
            firstMatch: [{}],
        };
        yield (0, device_utils_1.allocateDeviceForSession)(capabilities, 6000, 1000, pluginArgs).catch((error) => (0, chai_1.expect)(error)
            .to.be.an('error')
            .with.property('message', 'iosDeviceType value is set to "real" but app provided is not suitable for real device.'));
    }));
});
